!function(n){var e={};function r(o){if(e[o])return e[o].exports;var a=e[o]={i:o,l:!1,exports:{}};return n[o].call(a.exports,a,a.exports,r),a.l=!0,a.exports}r.m=n,r.c=e,r.d=function(n,e,o){r.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:o})},r.r=function(n){Object.defineProperty(n,"__esModule",{value:!0})},r.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return r.d(e,"a",e),e},r.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},r.p="",r(r.s=0)}({"./src/online-service/js/background.js":function(module,exports){eval('(function () {\n    `use strict`;\n\n    const MUSIC_SERVICES = [{\n        id: `bugs`,\n        name: `벅스`,\n        serviceUrl: `http://bugs.co.kr`,\n        playerUrlPattern: /.+music.bugs.co.kr\\/newPlayer.*/,\n        requestPatterns: [\n            `*://music.bugs.co.kr/newPlayer*`\n        ],\n        playerUI: {\n            playlist: `ul.playTrackList`\n        }\n    }, {\n        id: `naver`,\n        name: `네이버뮤직`,\n        serviceUrl: `http://music.naver.com`,\n        playerUrlPattern: /.+playerui.music.naver.com.+/,\n        requestPatterns: [\n            `*://playerui.music.naver.com/*`\n        ],\n        playerUI: {\n            playlist: `.songs_list`,\n            playBtn: `.player_controller .play:not(.is_paused)`\n        }\n    }, {\n        id: `mnet`,\n        name: `엠넷`,\n        serviceUrl: `http://www.mnet.com`,\n        playerUrlPattern: /.+www.mnet.com\\/player\\/.+/,\n        requestPatterns: [\n            `*://www.mnet.com/player/*`\n        ],\n        playerUI: {\n            playlist: `.mplayList ul`\n        }\n    }, {\n        id: `genie`,\n        name: `지니`,\n        serviceUrl: `http://www.genie.co.kr`,\n        playerUrlPattern: /.+www.genie.co.kr\\/\\w+layer.+/,\n        requestPatterns: [\n            `*://www.genie.co.kr/player/*`,\n            `*://www.genie.co.kr/mvPlayer/*`\n        ],\n        playerUI: {\n            playlist: `#conetnt .tab ul`,\n            playBtn: `p.control-2 .play`\n        },\n        popupSize: [\n            {\n                url: `www.genie.co.kr/player`,\n                width: 898,\n                height: 677\n            }, {\n                url: `www.genie.co.kr/mvPlayer`,\n                width: 1178,\n                height: 677\n            }\n        ]\n    }];\n\n    //const isIncognitoMode = whale.extension.inIncognitoContext;\n    const popupPlayer = {\n        url: ``,\n        width: 0,\n        height: 0\n    };\n    const currentPlayer = {\n        mode: `none`,\n        serviceInfo: null,\n        parentWindowId: null,\n        playerWindowId: null\n    };\n    let lastFocuedWindowId = null;\n\n    function init() {\n        whale.webRequest.onBeforeRequest.addListener(onBeforeRequest, {\n            urls: getRequestUrlPatterns(),\n            types: [`main_frame`]\n        });\n        whale.windows.onRemoved.addListener(onWindowRemoved);\n        whale.windows.onFocusChanged.addListener(onWindowFocused);\n        whale.commands.onCommand.addListener(onBrowserCommand);\n        wl.Storage.listen(`mode`, onPlayerModeUpdated);\n        wl.RuntimeMessage.listen(`musicplayer`, onRuntimeMessage);\n        wl.RuntimeMessage.listen(`localplayer`, onLocalPlayerMessage);\n\n        cleanupCrashTrash();\n    }\n\n    function cleanupCrashTrash() {\n        return new Promise(resolve => {\n            // [WHALE-2858] when genie player is active, it writes a\n            // `musicPlayer`cookie to value 1 and unwirtes it onBeforeUnload\n            // event handler, when the browser is inexpectly closed by crash or\n            // task manager the onBeforeUnload event handler is not called\n            // therefore genie player cannot be active again\n            whale.cookies.remove({\n                url: `http://www.genie.co.kr`,\n                name: `musicPlayer`\n            }, resolve);\n        });\n    }\n\n    function onBeforeRequest(request) {\n        if (isException(request)) {\n            return;\n        }\n\n        popupPlayer.url = request.url;\n\n        const promises = [];\n        promises.push(getWindowInfo(request));\n        promises.push(getPlayerMode());\n        Promise.all(promises)\n            .then(results => {\n                const [windowInfo, playerMode] = results;\n\n                if (windowInfo && windowInfo.type === `popup`) {\n                    if (playerMode.mode === `sidebar`) {\n                        if (playerMode.currentlyDocked) {\n                            replaceSidebarPlayer({\n                                currentParentWindowId: playerMode.currentlyDockedWindowIds[0],\n                                newPlayerWindowId: windowInfo.id\n                            });\n                        } else {\n                            dockPlayerToSidebar({\n                                playerWindowId: windowInfo.id\n                            });\n                        }\n                    } else if (playerMode.mode === `popup`) {\n                        saveCurrentMode(`popup`, {\n                            playerWindowId: windowInfo.id\n                        });\n                    } else {\n                        //console.error(`[onBeforeRequest] check player mode`, results);\n                    }\n                } else {\n                    // request is not from popup, reloading in sidebar mode\n                    if (playerMode.mode === `sidebar` && playerMode.currentlyDocked) {\n                        // [whale-bug/issues/289]\n                        // genie service reloads in sidebar and toggles between video and audio mode\n                        // must save last player url to resotre later in index page when restarting whale\n                        wl.Storage.set({\n                            playerUrl: popupPlayer.url\n                        });\n                    }\n                }\n            });\n    }\n\n    function isException(request) {\n        // [WHALE-3803] when naver music logs out it opens\n        // "https://playerui.music.naver.com/logout.html" in a popup window\n        if (request.url && request.url.includes(`logout.html`) === true) {\n            return true;\n        }\n        return false;\n    }\n\n    function onBrowserCommand(command) {\n        if (command === `toggle-musicplayer`) {\n            getPlayerMode()\n                .then(result => {\n                    wl.Storage.set({\n                        mode: result.mode === `sidebar` ? `popup` : `sidebar`\n                    });\n                    whale.sidebarAction.show();\n                });\n        }\n    }\n\n    function onWindowRemoved(windowId) {\n        if (lastFocuedWindowId === windowId) {\n            lastFocuedWindowId = null;\n        }\n\n        if (currentPlayer.mode === `sidebar` &&\n            currentPlayer.parentWindowId === windowId) {\n            saveCurrentMode(`popup`, {\n                playerWindowId: null\n            });\n        }\n    }\n\n    function onWindowFocused(windowId) {\n        if (windowId > 0) {\n            whale.windows.get(windowId, {\n                windowTypes: [`normal`]\n            }, result => {\n                if (whale.runtime.lastError) {\n                    return;\n                }\n                lastFocuedWindowId = result.id;\n            });\n        }\n    }\n\n    function onRuntimeMessage(message, sender, callback) {\n        if (message.action === `dockPlayerToSidebar` ||\n            message.action === `undockPlayerFromSidebar`) {\n            handlePlayerToggleMessage(message, sender.tab.windowId);\n        } else if (message.action === `moveSidebarPlayer`) {\n            moveSidebarPlayer(message.windowId);\n        } else if (message.action === `openServicePage`) {\n            openServicePage(message.url);\n        } else if (message.action === `getServiceInfo`) {\n            getServiceInfo(message.param, callback);\n        } else if (message.action === `getPlayerMode`) {\n            getPlayerMode(callback);\n        }\n\n        return true;\n    }\n\n    function onLocalPlayerMessage(message/*, sender ,callback*/) {\n        if (message === `localplayer-initialized`) {\n            getPlayerMode()\n                .then(result => {\n                    if (result.mode === `sidebar` && result.currentlyDocked) {\n                        undockPlayerFromSidebar({\n                            parentWindowId: result.currentlyDockedWindowIds[0],\n                            maintainOption: true,\n                            closePlayer: true\n                        });\n                    }\n                });\n        }\n    }\n\n    function handlePlayerToggleMessage(message, senderWindowId) {\n        getPlayerMode()\n            .then(result => {\n                if (result.mode === `sidebar` && result.currentlyDocked) {\n                    if (message.action === `dockPlayerToSidebar`) {\n                        replaceSidebarPlayer({\n                            currentParentWindowId: result.currentlyDockedWindowIds[0],\n                            newPlayerWindowId: senderWindowId\n                        });\n                    } else if (message.action === `undockPlayerFromSidebar`) {\n                        undockPlayerFromSidebar({\n                            parentWindowId: result.currentlyDockedWindowIds[0],\n                            closeSidebar: true,\n                            closePlayer: message.closePlayer\n                        });\n                    }\n                } else if (result.mode === `popup`) {\n                    if (message.action === `dockPlayerToSidebar`) {\n                        dockPlayerToSidebar({\n                            playerWindowId: senderWindowId\n                        });\n                    } else if (message.action === `undockPlayerFromSidebar`) {\n                        //console.error(`[handlePlayerToggleMessage] something is wrong`, message.action, senderWindowId);\n                    }\n                }\n            });\n    }\n\n    function moveSidebarPlayer(newParentWindowId) {\n        // move player from one window to another\n        const fromId = currentPlayer.parentWindowId;\n        const toId = newParentWindowId;\n\n        undockPlayerFromSidebar({ parentWindowId: fromId })\n            .then(playerId => {\n                dockPlayerToSidebar({\n                    playerWindowId: playerId,\n                    targetWindowId: toId\n                });\n            });\n    }\n\n    function replaceSidebarPlayer(param) {\n        // replace current sidebar player with another service popup player\n        undockPlayerFromSidebar({ parentWindowId: param.currentParentWindowId })\n            .then(playerId => closeWindow(playerId))\n            .then(() => dockPlayerToSidebar({ playerWindowId: param.newPlayerWindowId }))\n            .then(() => openSidebarAndGiveFocus(param.currentParentWindowId));\n    }\n\n    function openSidebarAndGiveFocus(windowId) {\n        return new Promise(resolve => {\n            whale.windows.update(windowId, {\n                focused: true\n            }, () => {\n                whale.sidebarAction.show(() => {\n                    resolve(windowId);\n                });\n            });\n        });\n    }\n\n    function dockPlayerToSidebar(param) {\n        // dock player to sidebar\n        getWindowSize(param.playerWindowId)\n            .then(result => {\n                popupPlayer.width = result.width;\n                popupPlayer.height = result.height;\n            })\n            .then(() => getTargetWindowId(param.targetWindowId))\n            .then(targetWindowId => openSidebarAndGiveFocus(targetWindowId))\n            .then(targetWindowId => {\n                const args = [\n                    param.playerWindowId,\n                    { windowId: targetWindowId }\n                ];\n\n                return new Promise(resolve => {\n                    whale.sidebarAction.dock(...args, resolve);\n                });\n            })\n            .then(parentWindowId => saveCurrentMode(`sidebar`, {\n                parentWindowId: parentWindowId,\n                playerUrl: popupPlayer.url\n            }))\n            .then(() => {\n                wl.RuntimeMessage.send(`localplayer`, `sidebarplayer-docked`);\n                return currentPlayer.parentWindowId;\n            });\n    }\n\n    function undockPlayerFromSidebar(param) {\n        // undock player from sidebar\n        const args = param.parentWindowId ? [param.parentWindowId] : [];\n        return new Promise(resolve => whale.sidebarAction.undock(...args, resolve))\n            .then(detachedPlayerId => {\n                if (param.closePlayer === true) {\n                    closeWindow(detachedPlayerId, 100)\n                        .then(() => {\n                            if (param.maintainOption === true) {\n                                wl.Storage.set({ mode: `sidebar` });\n                            }\n                        });\n                }\n                return param.closePlayer === true ? null : detachedPlayerId;\n            })\n            .then(playerId => saveCurrentMode(`popup`, {\n                playerWindowId: playerId,\n                playerUrl: null\n            }))\n            .then(restorePopupPlayerSize)\n            .then(() => currentPlayer.playerWindowId );\n    }\n\n    function restorePopupPlayerSize() {\n        const windowId = currentPlayer.playerWindowId;\n        return whale.tabs.query({\n            windowId: windowId\n        }, tabs => {\n            if (tabs && tabs.length === 1) {\n                const serviceInfo = getServiceInfo({\n                    url: tabs[0].url\n                });\n\n                if (serviceInfo && serviceInfo.popupSize) {\n                    serviceInfo.popupSize.forEach(sizeInfo => {\n                        if (tabs[0].url.includes(sizeInfo.url)) {\n                            whale.windows.update(windowId, {\n                                width: sizeInfo.width,\n                                height: sizeInfo.height,\n                                focused: true\n                            });\n                        }\n                    });\n                } else {\n                    whale.windows.update(windowId, {\n                        width: popupPlayer.width,\n                        height: popupPlayer.height,\n                        focused: true\n                    });\n                }\n            }\n        });\n    }\n\n    function closeWindow(windowId, delay) {\n        return new Promise(resolve => {\n            setTimeout(() => {\n                if (windowId) {\n                    whale.windows.remove(windowId, resolve);\n                } else {\n                    resolve();\n                }\n            }, delay || 0);\n        });\n    }\n\n    function getWindowInfo(request) {\n        return new Promise(resolve => {\n            whale.tabs.get(request.tabId, tabInfo => {\n                void chrome.runtime.lastError;\n                if (tabInfo && tabInfo.windowId) {\n                    whale.windows.get(tabInfo.windowId, windowInfo => {\n                        resolve(windowInfo);\n                    });\n                } else {\n                    resolve(null);\n                }\n            });\n        });\n    }\n\n    function openServicePage(playerUrl) {\n        const serviceInfo = getServiceInfo({\n            url: playerUrl\n        });\n\n        if (serviceInfo) {\n            whale.tabs.create({\n                url: serviceInfo.serviceUrl\n            });\n        }\n    }\n\n    function onPlayerModeUpdated(newMode) {\n        if (newMode === `sidebar`\n            && currentPlayer.mode === `popup`\n            && currentPlayer.playerWindowId !== null) {\n            dockPlayerToSidebar({\n                playerWindowId: currentPlayer.playerWindowId\n            });\n        } else if (newMode === `popup`\n            && currentPlayer.mode === `sidebar`\n            && currentPlayer.parentWindowId !== null) {\n            undockPlayerFromSidebar({\n                parentWindowId: currentPlayer.parentWindowId\n            });\n        }\n    }\n\n    function getTargetWindowId(windowId) {\n        return new Promise(resolve => {\n            if (windowId) {\n                // verify if existing window\n                whale.windows.get(windowId, () => {\n                    resolve(windowId);\n                });\n            } else {\n                whale.windows.getAll(result => {\n                    if (result.length === 1 && result[0].type === `popup`) {\n                        // if there is no window to dock, create new window\n                        whale.windows.create(windowInfo => {\n                            resolve(windowInfo.id);\n                        });\n                    } else {\n                        // get last focused window id\n                        if (lastFocuedWindowId) {\n                            resolve(lastFocuedWindowId);\n                        } else {\n                            whale.windows.getLastFocused({\n                                windowTypes: [`normal`]\n                            }, windowInfo => {\n                                resolve(windowInfo.id);\n                            });\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    function getWindowSize(windowId) {\n        return new Promise(resolve => {\n            if (windowId) {\n                whale.windows.get(windowId, resolve);\n            } else {\n                resolve(null);\n            }\n        });\n    }\n\n    function getPlayerMode(callback) {\n        const promises = [];\n        promises.push(wl.Storage.get(`mode`));\n        promises.push(getDockedWindows());\n        promises.push(wl.Storage.get(`playerUrl`));\n        return Promise.all(promises)\n            .then(results => {\n                const args = {\n                    mode: results[0].mode,\n                    currentlyDocked: results[1].currentlyDocked,\n                    currentlyDockedWindowIds: results[1].currentlyDockedWindowIds,\n                    playerUrl: results[2].playerUrl\n                };\n\n                // if (args.mode === `popup` && args.currentlyDocked === true) {\n                //     console.error(`[getPlayerMode] something is wrong`, args);\n                // }\n\n                callback && callback(args);\n                return args;\n            });\n    }\n\n    function getDockedWindows() {\n        const isIncognito = whale.extension.inIncognitoContext;\n        return new Promise(resolve => whale.sidebarAction.getDocked(resolve))\n            .then(windowIds => {\n                const promises = windowIds.map(id => {\n                    return new Promise(resolve => whale.windows.get(id, windowInfo => {\n                        resolve((windowInfo && windowInfo.incognito === isIncognito) ? id : null);\n                    }));\n                });\n                return Promise.all(promises);\n            })\n            .then(ids => {\n                const result = {\n                    currentlyDockedWindowIds: []\n                };\n                ids.forEach(id => {\n                    id && result.currentlyDockedWindowIds.push(id);\n                });\n                result.currentlyDocked = result.currentlyDockedWindowIds.length > 0;\n                return result;\n            });\n    }\n\n    function saveCurrentMode(mode, param) {\n        return new Promise(resolve => {\n            currentPlayer.mode = mode;\n            currentPlayer.playerUrl = param.playerUrl;\n            if (mode === `sidebar`) {\n                currentPlayer.playerWindowId = null;\n                currentPlayer.parentWindowId = param.parentWindowId;\n            } else if (mode === `popup`) {\n                currentPlayer.playerWindowId = param.playerWindowId;\n                currentPlayer.parentWindowId = null;\n            }\n            wl.Storage.set(currentPlayer).then(resolve);\n        });\n    }\n\n    function getServiceInfo(param, callback) {\n        if (param) {\n            // [WHALE-1387] when naver music logs out it opens\n            // "https://playerui.music.naver.com/logout.html" in a popup window\n            if (param.url && param.url.includes(`logout.html`) === true) {\n                return null;\n            }\n\n            for (let i = 0, len = MUSIC_SERVICES.length; i < len; i++) {\n                const re = new RegExp(MUSIC_SERVICES[i].playerUrlPattern);\n                if ((param.url && param.url.match(re)) ||\n                    (param.id && param.id === MUSIC_SERVICES[i].id)) {\n                    currentPlayer.serviceInfo = MUSIC_SERVICES[i];\n                    if (callback) {\n                        callback(MUSIC_SERVICES[i]);\n                    }\n                    return MUSIC_SERVICES[i];\n                }\n            }\n        }\n\n        return null;\n    }\n\n    function getRequestUrlPatterns() {\n        let result = [];\n        MUSIC_SERVICES.forEach(item => {\n            result = result.concat(item.requestPatterns);\n        });\n        return result;\n    }\n\n    function cleanup() {\n        return getPlayerMode()\n            .then(result => {\n                if (result.currentlyDocked === true) {\n                    undockPlayerFromSidebar({\n                        closePlayer: true\n                    });\n                } else {\n                    closeWindow(currentPlayer.playerWindowId);\n                }\n                saveCurrentMode(result.mode || `popup`, {\n                    playerWindowId: null\n                });\n            });\n    }\n\n    cleanup().then(init);\n})();\n\n\n//# sourceURL=webpack:///./src/online-service/js/background.js?')},"./src/wl.RuntimeMessage.js":function(module,exports){eval("/**\n * Copyright 2016 NAVER Corp. All Rights reserved.\n * All rights, including but not limited to, copyrights,\n * and intellectual property rights of this source code are owned by NAVER Corp.\n *\n * You may not use, reproduce, modify, or distribute this source code\n * without prior written permission from NAVER Corp.\n *\n * @author Kim Jihan <kim.jihan@navercorp.com>\n */\nwindow.wl = window.wl || {};\nwindow.wl.RuntimeMessage = window.wl.RuntimeMessage || (function () {\n    `use strict`;\n\n    const listeners = {};\n    whale.runtime.onMessage.addListener(onMessageReceived);\n\n    function onMessageReceived(message, sender, sendResponse) {\n        if (message.namespace && Array.isArray(listeners[message.namespace])) {\n            listeners[message.namespace].forEach(listener => {\n                listener(message.message, sender, sendResponse);\n            });\n        }\n\n        return true;\n    }\n\n    function addListener(namespace, listener) {\n        listeners[namespace] = listeners[namespace] || [];\n        listeners[namespace].push(listener);\n    }\n\n    function sendMessage(namespace, message, tabId, frameId) {\n        return new Promise(resolve => {\n            if (typeof tabId !== `undefined` && tabId > -1) {\n                whale.tabs.sendMessage(tabId, {\n                    namespace: namespace,\n                    message: message\n                },\n                (typeof frameId !== `undefined` && frameId > -1) ? { frameId: frameId } : {},\n                response => {\n                    resolve(response);\n                });\n            } else {\n                whale.runtime.sendMessage({\n                    namespace: namespace,\n                    message: message\n                }, response => {\n                    resolve(response);\n                });\n            }\n        });\n    }\n\n    function broadcast(namespace, message) {\n        // broadcasting available only in background\n        if (!whale.tabs) {\n            return new Promise((resolve, reject) => {\n                reject();\n            });\n        }\n\n        const promised = [];\n        whale.tabs.query({}, tabs => {\n            tabs.forEach(tab => {\n                promised.push(new Promise(resolve => {\n                    whale.tabs.sendMessage(tab.id, {\n                        namespace: namespace,\n                        message: message\n                    }, response => {\n                        resolve(response);\n                    });\n                }));\n            });\n        });\n\n        return Promise.all(promised);\n    }\n\n    return {\n        broadcast: broadcast,\n        listen: addListener,\n        send: sendMessage\n    };\n})();\n\n\n//# sourceURL=webpack:///./src/wl.RuntimeMessage.js?")},"./src/wl.Storage.js":function(module,exports){eval("/**\n * Copyright 2016 NAVER Corp. All Rights reserved.\n * All rights, including but not limited to, copyrights,\n * and intellectual property rights of this source code are owned by NAVER Corp.\n *\n * You may not use, reproduce, modify, or distribute this source code\n * without prior written permission from NAVER Corp.\n *\n */\nwindow.wl = window.wl || {};\nwindow.wl.Storage = window.wl.Storage || (function () {\n    `use strict`;\n\n    const prefix = whale.extension.inIncognitoContext ? `incognito_` : `normal_`;\n    const listeners = {};\n\n    function get(key) {\n        return new Promise(resolve => {\n            key = prefix + key;\n            whale.storage.local.get(key, result => {\n                const clone = {};\n                for (const key in result) {\n                    clone[key.split(prefix)[1]] = result[key];\n                }\n                resolve(clone);\n            });\n        });\n    }\n\n    function set(param) {\n        const clone = {};\n        return new Promise(resolve => {\n            for (const key in param) {\n                clone[prefix + key] = param[key];\n            }\n            whale.storage.local.set(clone, resolve);\n        });\n    }\n\n    function listen(param, callback) {\n        if (typeof param === `string`) {\n            listeners[prefix + param] = callback;\n        } else {\n            param.forEach(key => {\n                listeners[prefix + key] = callback;\n            });\n        }\n    }\n\n    function onStorageChange(result) {\n        for (const key in result) {\n            if (listeners[key]) {\n                listeners[key](result[key].newValue);\n            }\n        }\n    }\n\n    whale.storage.onChanged.addListener(onStorageChange);\n\n    return {\n        get, set, listen\n    };\n})();\n\n\n//# sourceURL=webpack:///./src/wl.Storage.js?")},0:function(module,exports,__webpack_require__){eval('__webpack_require__(/*! ./src/wl.Storage.js */"./src/wl.Storage.js");\n__webpack_require__(/*! ./src/wl.RuntimeMessage.js */"./src/wl.RuntimeMessage.js");\nmodule.exports = __webpack_require__(/*! ./src/online-service/js/background.js */"./src/online-service/js/background.js");\n\n\n//# sourceURL=webpack:///multi_./src/wl.Storage.js_./src/wl.RuntimeMessage.js_./src/online-service/js/background.js?')}});